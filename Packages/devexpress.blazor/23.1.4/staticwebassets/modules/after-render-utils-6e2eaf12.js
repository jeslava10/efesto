function t(t,e){const o=t.ownerDocument.getElementById(e);if(null!==o){const e=o.getBoundingClientRect(),i=t.getBoundingClientRect();return new Promise(((n,r)=>{requestAnimationFrame((r=>{!(t.compareDocumentPosition(document.body)&Node.DOCUMENT_POSITION_DISCONNECTED)&&e.top>i.top&&o.scrollTop>0&&(o.scrollTop=0),n()}))}))}return Promise.resolve()}async function e(t,e){const o=await e.arrayBuffer(),i=URL.createObjectURL(new Blob([o])),n=document.createElement("a");return document.body.appendChild(n),n.href=i,n.download=null!=t?t:"",n.click(),n.remove(),URL.revokeObjectURL(i),Promise.resolve()}async function o(t,e,...o){return await async function(t){const e=t.tagName;-1!==e.indexOf("-")&&await customElements.whenDefined(e.toLowerCase())}(t),await function(t,e,...o){return new Promise(((i,n)=>{try{const n=t[e].call(t,...o);n&&n.then?n.then(i):i(n)}catch(t){n(t)}}))}(t,e,...o)}class i{constructor(t,e,o,i,n,r,s,c){this.targetWidth=0,this.targetHeight=0,this.targetPositionX=0,this.targetPositionY=0,this.viewPortWidth=0,this.viewPortHeight=0,this.viewPortScrollHeight=0,this.viewPortScrollWidth=0,this.targetWidth=t,this.targetHeight=e,this.targetPositionX=o,this.targetPositionY=i,this.viewPortWidth=n,this.viewPortHeight=r,this.viewPortScrollWidth=s,this.viewPortScrollHeight=c}}function n(t){const e=document.querySelector(t);if(null===t)throw new Error("Position target does not exist");const o=e.getBoundingClientRect();return new i(Math.floor(o.width),Math.floor(o.height),Math.floor(o.x),Math.floor(o.y),Math.floor(window.innerWidth),Math.floor(window.innerHeight),Math.floor(window.scrollX),Math.floor(window.scrollY))}export{e as downloadFileFromStream,n as getLayoutAttributes,o as invokeMethod,t as scrollIntoView};
